<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gravity Text Editor</title>
    <!-- Import de Matter.js pour la physique -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <!-- Tailwind pour l'UI minimaliste -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Empêche le scroll, c'est une app canvas */
            background-color: #f3f4f6;
            font-family: 'Inter', sans-serif;
            cursor: text;
            touch-action: none; /* Important pour le drag & drop sur mobile */
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* L'interface utilisateur flottante */
        #ui-layer {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            display: flex;
            gap: 10px;
        }

        .btn {
            background: white;
            border: 1px solid #e5e7eb;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            color: #374151;
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            transition: all 0.2s ease;
            user-select: none;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        .btn:active {
            transform: translateY(0);
        }

        /* Indicateur de frappe en cours */
        #typing-indicator {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2rem;
            color: #9ca3af;
            z-index: 5;
            pointer-events: none; /* Laisse passer les clics vers le canvas */
            min-height: 3rem;
            text-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #9ca3af;
            font-size: 0.8rem;
            z-index: 0;
            pointer-events: none;
            text-align: center;
        }
    </style>
</head>
<body>

    <!-- Zone de prévisualisation de ce qu'on tape -->
    <div id="typing-indicator"></div>

    <!-- UI Controls -->
    <div id="ui-layer">
        <button class="btn" id="btn-gravity">G: ON</button>
        <button class="btn" id="btn-clear">Tout Effacer</button>
    </div>

    <div id="instructions">Tapez au clavier. [Espace] pour matérialiser. Souris pour attraper. Secouez la fenêtre.</div>

    <!-- Le monde physique -->
    <div id="canvas-container"></div>

    <script>
        // --- CONFIGURATION ---
        const FONT_SIZE = 24;
        const FONT_FAMILY = "Inter, sans-serif";
        const TEXT_COLOR = "#111827";
        
        // --- INIT MATTER.JS ---
        const Engine = Matter.Engine,
              Render = Matter.Render,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Composite = Matter.Composite,
              Mouse = Matter.Mouse,
              MouseConstraint = Matter.MouseConstraint,
              Events = Matter.Events,
              Body = Matter.Body,
              Vector = Matter.Vector;

        // Création du moteur
        const engine = Engine.create();
        const world = engine.world;

        // Gestion correcte du Pixel Ratio (Retina/High DPI)
        const pixelRatio = window.devicePixelRatio || 1;

        // Configuration du rendu
        const container = document.getElementById('canvas-container');
        const render = Render.create({
            element: container,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                background: 'transparent',
                wireframes: false, 
                pixelRatio: pixelRatio // Crucial pour la netteté et la souris
            }
        });

        // --- MURS ET SOL ---
        let ground, leftWall, rightWall, topWall; // Ajout d'un plafond lointain au cas où
        
        function createBoundaries() {
            const thickness = 200; // Murs beaucoup plus épais pour éviter le "tunneling"
            const width = window.innerWidth;
            const height = window.innerHeight;

            // Supprimer les anciens s'ils existent
            if(ground) Composite.remove(world, [ground, leftWall, rightWall, topWall]);

            // Le sol est positionné juste en dessous de la vue visible
            // Position y = height + (thickness/2) - (offset léger pour voir le bas des lettres)
            ground = Bodies.rectangle(width / 2, height + thickness/2, width + 200, thickness, { 
                isStatic: true, 
                friction: 0.5,
                render: { visible: false } 
            });
            
            leftWall = Bodies.rectangle(0 - thickness/2, height / 2, thickness, height * 2, { 
                isStatic: true, 
                render: { visible: false } 
            });
            
            rightWall = Bodies.rectangle(width + thickness/2, height / 2, thickness, height * 2, { 
                isStatic: true, 
                render: { visible: false } 
            });

            // Plafond très haut pour éviter que les mots ne s'envolent à jamais si on secoue fort
            topWall = Bodies.rectangle(width / 2, -height , width * 2, thickness, {
                isStatic: true,
                render: { visible: false }
            });

            Composite.add(world, [ground, leftWall, rightWall, topWall]);
        }
        
        createBoundaries();

        // --- GESTION DE LA SOURIS (CORRECTIF) ---
        // On attache la souris au rendu pour qu'elle prenne en compte le pixelRatio
        const mouse = Mouse.create(render.canvas);
        
        // Fix pour l'interaction sur écrans haute densité (le problème "on n'arrive pas à attraper")
        mouse.pixelRatio = pixelRatio; 

        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.2,
                angularStiffness: 0.1,
                render: { visible: false }
            }
        });
        Composite.add(world, mouseConstraint);
        render.mouse = mouse; 

        // --- LOGIQUE DE CRÉATION DE MOTS ---
        
        function createWordBody(text, x, y) {
            const ctx = render.context;
            // On s'assure de mesurer avec la police à l'échelle
            ctx.font = `600 ${FONT_SIZE}px ${FONT_FAMILY}`;
            const metrics = ctx.measureText(text);
            
            const width = metrics.width + 16; 
            const height = FONT_SIZE + 10;   

            const body = Bodies.rectangle(x, y, width, height, {
                restitution: 0.6, // Un peu plus rebondissant
                friction: 0.1,
                frictionAir: 0.01, // Résistance à l'air pour un mouvement plus naturel
                chamfer: { radius: 4 },
                density: 0.001 * (width / 50), // Masse variable selon la longueur du mot
                plugin: { 
                    text: text,
                    width: width,
                    height: height
                }
            });

            // Vitesse initiale aléatoire légère pour le "jus"
            Body.setVelocity(body, { 
                x: (Math.random() - 0.5) * 2, 
                y: (Math.random() - 0.5) * 2 
            });

            Composite.add(world, body);
        }

        // --- BOUCLE DE RENDU PERSONNALISÉE ---
        Events.on(render, 'afterRender', function() {
            const ctx = render.context;
            const bodies = Composite.allBodies(world);

            ctx.font = `600 ${FONT_SIZE}px ${FONT_FAMILY}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = TEXT_COLOR;

            bodies.forEach(body => {
                if (body.plugin && body.plugin.text) {
                    const { x, y } = body.position;
                    const angle = body.angle;

                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle);
                    ctx.fillText(body.plugin.text, 0, 1);
                    ctx.restore();
                }
            });
        });

        // --- GESTION DE L'INPUT ---
        let currentInput = "";
        const typingDisplay = document.getElementById('typing-indicator');

        document.addEventListener('keydown', (e) => {
            if (e.metaKey || e.ctrlKey) return;

            if (e.key === "Backspace") {
                currentInput = currentInput.slice(0, -1);
            } else if (e.key === " " || e.key === "Enter") {
                e.preventDefault();
                if (currentInput.trim() !== "") {
                    // Spawn légèrement aléatoire pour éviter l'empilement parfait
                    const randomX = (Math.random() - 0.5) * 40;
                    createWordBody(currentInput, (window.innerWidth / 2) + randomX, 150);
                    currentInput = "";
                }
            } else if (e.key.length === 1) {
                currentInput += e.key;
            }

            typingDisplay.textContent = currentInput + "|";
            typingDisplay.style.opacity = 1;
        });

        // --- GESTION DU "SECOUER LA FENÊTRE" ---
        let lastScreenX = window.screenX;
        let lastScreenY = window.screenY;

        // Boucle de détection de position de la fenêtre (60fps)
        function checkWindowShake() {
            // Calcul du déplacement de la fenêtre depuis la dernière frame
            const deltaX = window.screenX - lastScreenX;
            const deltaY = window.screenY - lastScreenY;
            
            // Si la fenêtre a bougé
            if (Math.abs(deltaX) > 0 || Math.abs(deltaY) > 0) {
                const bodies = Composite.allBodies(world);
                
                // Force multiplier : Ajuster selon la sensibilité voulue
                const forceMult = 0.002; 

                bodies.forEach(body => {
                    if (!body.isStatic) {
                        // On applique une force inverse au mouvement de la fenêtre (Inertie)
                        // Si je tire la fenêtre à droite, les objets doivent "rester sur place" donc aller à gauche
                        Body.applyForce(body, body.position, {
                            x: -deltaX * forceMult * body.mass,
                            y: -deltaY * forceMult * body.mass
                        });
                    }
                });
            }
            
            lastScreenX = window.screenX;
            lastScreenY = window.screenY;
            
            requestAnimationFrame(checkWindowShake);
        }

        // Démarrer la surveillance sismique
        checkWindowShake();


        // --- UI ---
        let gravityEnabled = true;
        document.getElementById('btn-gravity').addEventListener('click', (e) => {
            gravityEnabled = !gravityEnabled;
            e.target.innerText = gravityEnabled ? "G: ON" : "G: OFF";
            engine.gravity.y = gravityEnabled ? 1 : 0;
            
            if (!gravityEnabled) {
                Composite.allBodies(world).forEach(body => {
                    if(!body.isStatic) Body.setVelocity(body, { 
                        x: (Math.random() - 0.5) * 5, 
                        y: (Math.random() - 0.5) * 5 
                    });
                });
            }
        });

        document.getElementById('btn-clear').addEventListener('click', () => {
            const bodies = Composite.allBodies(world);
            const bodiesToRemove = bodies.filter(b => b.plugin && b.plugin.text);
            Composite.remove(world, bodiesToRemove);
            currentInput = "";
            typingDisplay.textContent = "";
        });

        // --- REDIMENSIONNEMENT ROBUSTE ---
        window.addEventListener('resize', () => {
            // Mettre à jour les dimensions du canvas interne ET du style CSS
            render.canvas.width = window.innerWidth * pixelRatio;
            render.canvas.height = window.innerHeight * pixelRatio;
            render.canvas.style.width = `${window.innerWidth}px`;
            render.canvas.style.height = `${window.innerHeight}px`;
            
            // Recréer les murs aux nouvelles positions
            createBoundaries();
        });

        // --- LANCEMENT ---
        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);

        // Intro
        setTimeout(() => createWordBody("Secoue", window.innerWidth/2 - 60, 200), 500);
        setTimeout(() => createWordBody("Moi", window.innerWidth/2 + 60, 150), 1000);

    </script>
</body>
</html>